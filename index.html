<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>BL2 Random Playthrough Picker</title>
  <link rel="stylesheet" href="styles.css" />
</head>
<body>
  <div class="stage">
    <div class="hero">
      <div class="title">Vault Hunter Run Forge</div>
      <div class="tagline">Dial in your chaos level, let the randomiser weave its story, and drop into Pandora with a handcrafted loadout.</div>
    </div>

    <div class="panel">
      <div class="panel-title">Choose Your Intensity</div>
      <div class="row stack">
        <div>
          <div class="difficulty-header">
            <span class="panel-subtitle">Difficulty</span>
            <div id="difficulty-options" class="chip-group" role="group" aria-label="Difficulty selector">
              <button type="button" class="chip" data-difficulty="relaxed" data-active="false">Relaxed</button>
              <button type="button" class="chip" data-difficulty="standard" data-active="true">Balanced</button>
              <button type="button" class="chip" data-difficulty="mayhem" data-active="false">Mayhem</button>
            </div>
          </div>
          <div id="difficulty-description" class="muted small difficulty-notes"></div>
        </div>
        <div class="actions">
          <button id="randomise" class="btn">Forge This Run</button>
          <button id="download-run" class="btn ghost">Save Plan</button>
          <div class="seed-wrap">
            <span class="muted">Seed</span>
            <input id="seed" type="text" placeholder="optional" />
          </div>
        </div>
      </div>
    </div>

    <div class="panel">
      <div class="panel-title">Mission Briefing</div>
      <div id="result" class="result">
        <div id="result-summary" class="result-summary">Stand by for deployment. Pick a difficulty and forge your run.</div>
        <div class="result-grid-wrapper">
          <div id="result-grid" class="result-grid"></div>
        </div>
      </div>
    </div>
  </div>

  <script id="embedded-config" type="text/plain"># BL2 Randomiser config v1
# Lines starting with # are ignored.
# Each section begins with [Category: <Name>] optionally followed by pick=<n>

[Category: Character] pick=1
Axton (Commando)
Zer0 (Assassin)
Salvador (Gunzerker)
Maya (Siren)
Gaige (Mechromancer)
Kreig (Psycho)

[Category: Manufacturer] pick=1
Bandit
Dahl
Hyperion
Jakobs
Maliwan
Tediore
Torgue
Vladof

[Category: Weapon Type] pick=2
Pistol
Assault Rifle
Rocket Launcher
Shotgun
SMG
Sniper Rifle

[Category: Shield] pick=1
Tediore
Anshin
Pangolin
Torgue
Hyperion
Bandit
Dahl
Vladof
Maliwan

[Category: Grenade Mod] pick=1
Bandit
Dahl
Hyperion
Maliwan
Tediore
Torgue
Vladof

[Category: Relic] pick=1
Vitality
Allegiance
Stockpile
Protection
Agression
Resistance
Tenacity
Elemental
Proficiency
Strength

[Category: Item Rarity] pick=1
White
Green
Blue
Purple
Legendary (Orange)
</script>
  <script>
  const state = { categories: [], difficulty: 'standard', configSource: 'pending' };

  const ADVANCED_CATEGORY_KEYS = ['grenademod','relic','shield','insaneplaythroughs','insanitydoseometer'];
  const RELAXED_CORE_KEYS = ['character','manufacturer','weapontype','weaponstype','itemsweapontypes','itemrarity','rarities'];
    const AWKWARD_ITEMS = {
      manufacturer: ['Tediore', 'Bandit', 'Jakobs', 'Torgue'],
      weapontype: ['Rocket Launcher', 'Sniper Rifle', 'Shotgun'],
      shield: ['Pangolin', 'Bandit', 'Torgue'],
      grenademod: ['Vladof', 'Torgue', 'Tediore'],
      relic: ['Tenacity', 'Resistance', 'Proficiency'],
      itemrarity: ['Legendary (Orange)']
    };

    const difficultyProfiles = {
      relaxed: {
        label: 'Relaxed',
        description: 'Focuses on signature choices and trims the chaos for a breezy run.',
        prepare(baseCats, rng) {
          const core = baseCats.filter(cat => !isAdvanced(cat.name) && isRelaxedCore(cat.name));
          if (!core.length) return cloneForStandard(baseCats);
          const limit = Math.min(core.length, 6);
          const chosen = seededShuffle(core, rng).slice(0, limit);
          return chosen.map(cat => {
            const copy = cloneCategory(cat);
            const filtered = filterOutAwkward(copy.items, copy.name);
            copy.items = filtered.length ? filtered : copy.items.slice();
            copy.pick = Math.max(1, Math.min(copy.pick, 2, copy.items.length));
            copy.strategy = 'relaxed';
            copy.avoidAwkward = true;
            return copy;
          });
        }
      },
      standard: {
        label: 'Balanced',
        description: 'A classic randomiser experience touching every category once.',
        prepare(baseCats) {
          return cloneForStandard(baseCats);
        }
      },
      mayhem: {
        label: 'Mayhem',
        description: 'Dialled-up chaos: extra picks, awkward loadouts, and surprise wildcards.',
        prepare(baseCats, rng) {
          return baseCats.map(cat => {
            const copy = cloneCategory(cat);
            copy.strategy = 'mayhem';
            const awkwardPool = getAwkwardPool(copy);
            copy.forceAwkward = awkwardPool;
            if (copy.items.length > 1) {
              copy.pick = Math.min(copy.items.length, copy.pick + 1);
            }
            copy.bonusRoll = copy.items.length > copy.pick && rng() > 0.45;
            return copy;
          });
        }
      }
    };

    const DIFFICULTY_FLAVOUR = {
      relaxed: 'Chill run. Focused kit, minimal constraints, maximal vibes.',
      standard: 'Classic vault hunting. Every pillar represented with balanced picks.',
      mayhem: 'Full-throttle pandemonium. Expect curveballs, awkward gear, and extra pulls.'
    };

    const CARD_PALETTES = [
      { from: '#ffe66d', to: '#ef6f6c' },
      { from: '#b6f7ff', to: '#2bb5ff' },
      { from: '#f4cafe', to: '#b5179e' },
      { from: '#d3f36b', to: '#4cc9f0' },
      { from: '#f7d488', to: '#f15bb5' },
      { from: '#cddafd', to: '#7209b7' }
    ];

    function normalizeName(name){
      return (name || '').trim().toLowerCase();
    }

    function normalizeItem(item){
      return (item || '').trim().toLowerCase();
    }

    function sanitizeKey(name){
      return normalizeName(name).replace(/[^a-z0-9]/g, '');
    }

    function isAdvanced(name){
      const key = sanitizeKey(name);
      return ADVANCED_CATEGORY_KEYS.some(adv => key.includes(adv));
    }

    function isRelaxedCore(name){
      const key = sanitizeKey(name);
      return RELAXED_CORE_KEYS.some(core => key.includes(core));
    }

    function cloneCategory(cat){
      return { name: cat.name, pick: cat.pick, items: cat.items.slice() };
    }

    function cloneForStandard(baseCats){
      return baseCats.map(cat => {
        const copy = cloneCategory(cat);
        copy.strategy = 'standard';
        copy.forceAwkward = getAwkwardPool(copy);
        return copy;
      });
    }

    function resolveAwkwardList(categoryName){
      const key = sanitizeKey(categoryName);
      const match = Object.keys(AWKWARD_ITEMS).find(k => key.includes(k));
      return match ? AWKWARD_ITEMS[match] : null;
    }

    function filterOutAwkward(items, categoryName){
      const awkward = resolveAwkwardList(categoryName);
      if (!awkward) return items.slice();
      const awkwardSet = new Set(awkward.map(normalizeItem));
      return items.filter(item => !awkwardSet.has(normalizeItem(item)));
    }

    function getAwkwardPool(cat){
      const awkward = resolveAwkwardList(cat.name);
      if (!awkward) return [];
      const awkwardSet = new Set(awkward.map(normalizeItem));
      return cat.items.filter(item => awkwardSet.has(normalizeItem(item)));
    }

    function parseConfig(text) {
      const lines = text.split(/\r?\n/);
      const cats = [];
      let current = null;
      for (let raw of lines) {
        const line = raw.trim();
        if (!line || line.startsWith('#')) continue;
        const m = line.match(/^\[Category:\s*(.+?)\]\s*(pick\s*=\s*(\d+))?/i);
        if (m) {
          if (current) cats.push(current);
          current = { name: m[1], pick: m[3] ? parseInt(m[3],10):1, items: [] };
        } else if (current) {
          current.items.push(line);
        }
      }
      if (current) cats.push(current);
      return cats;
    }

  const resultSummaryEl = document.getElementById('result-summary');
    const resultGridEl = document.getElementById('result-grid');

    function showStatus(message){
      if (resultSummaryEl) {
        resultSummaryEl.textContent = message;
      }
      if (resultGridEl) {
        resultGridEl.innerHTML = '';
      }
    }

    function renderResultSummary(profileLabel, seedText, source, flavour){
      if (!resultSummaryEl) return;
      const lines = [
        `${profileLabel} Deployment Loaded`,
        `Seed: ${seedText}`,
        `Source: ${source}`
      ];
      if (flavour) {
        lines.push(flavour);
      }
      resultSummaryEl.textContent = lines.join('\n');
    }

    function renderResultGrid(picks){
      if (!resultGridEl) return;
      resultGridEl.innerHTML = '';
      let paletteIndex = 0;
      picks.forEach(pick => {
        pick.items.forEach((item, idx) => {
          const palette = CARD_PALETTES[paletteIndex % CARD_PALETTES.length];
          paletteIndex += 1;
          const card = document.createElement('div');
          card.className = 'drop-card';
          card.style.setProperty('--card-from', palette.from);
          card.style.setProperty('--card-to', palette.to);

          const categoryEl = document.createElement('div');
          categoryEl.className = 'drop-category';
          categoryEl.textContent = pick.name;
          card.appendChild(categoryEl);

          const titleEl = document.createElement('div');
          titleEl.className = 'drop-title';
          titleEl.textContent = item;
          card.appendChild(titleEl);

          if (pick.bonusApplied && idx >= pick.planned) {
            const bonusEl = document.createElement('div');
            bonusEl.className = 'drop-footnote';
            bonusEl.textContent = 'Bonus Roll';
            card.appendChild(bonusEl);
          }

          resultGridEl.appendChild(card);
        });
      });
      resultGridEl.scrollTop = 0;
    }

    async function bootstrapConfig(){
      showStatus('Syncing loadout archives...');
      await loadConfigFromDisk();
      updateDifficultyDescription();
      updateDifficultyChips();
      if (state.categories.length){
        showStatus('Archives synced. Pick a difficulty and forge your run.');
      } else {
        showStatus('No configuration data found. Ensure config.txt sits beside this page.');
      }
    }

    async function loadConfigFromDisk(){
      const fallbackNode = document.getElementById('embedded-config');
      const fallbackText = fallbackNode ? fallbackNode.textContent : '';
      try {
        const response = await fetch('config.txt', { cache: 'no-store' });
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        const text = await response.text();
        const parsed = parseConfig(text);
        if (!parsed.length) throw new Error('Config appears empty');
        state.categories = parsed;
        state.configSource = 'config.txt';
      } catch (err) {
        console.warn('Falling back to embedded config', err);
        if (fallbackText) {
          const parsed = parseConfig(fallbackText);
          state.categories = parsed;
          state.configSource = 'embedded fallback';
        } else {
          state.categories = [];
          state.configSource = 'unavailable';
        }
      }
    }

    function mulberry32(a){return function(){
      let t = a += 0x6D2B79F5;
      t = Math.imul(t ^ t >>> 15, t | 1);
      t ^= t + Math.imul(t ^ t >>> 7, t | 61);
      return ((t ^ t >>> 14) >>> 0) / 4294967296;
    }}

    function seededShuffle(arr, rng) {
      const a = arr.slice();
      for (let i=a.length-1;i>0;i--) {
        const j = Math.floor(rng()* (i+1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    function selectDifficulty(key){
      if (!difficultyProfiles[key]) return;
      state.difficulty = key;
      updateDifficultyChips();
      updateDifficultyDescription();
    }

    function updateDifficultyChips(){
      document.querySelectorAll('#difficulty-options .chip').forEach(chip => {
        chip.setAttribute('data-active', chip.dataset.difficulty === state.difficulty ? 'true' : 'false');
      });
    }

    function updateDifficultyDescription(){
      const profile = difficultyProfiles[state.difficulty];
      document.getElementById('difficulty-description').textContent = profile ? profile.description : '';
    }

    function ensureAwkwardPresence(selection, pool, awkwardPool){
      if (!awkwardPool || !awkwardPool.length) return selection;
      const hasAwkward = selection.some(item => awkwardPool.includes(item));
      if (hasAwkward) return selection;
      const awkwardCandidate = pool.find(item => awkwardPool.includes(item));
      if (!awkwardCandidate) return selection;
      const next = selection.slice();
      next[next.length - 1] = awkwardCandidate;
      return next;
    }

    function randomise() {
      if (!state.categories.length) {
        showStatus('Loadout archives unavailable. Ensure config.txt is present beside index.html.');
        return;
      }
      const seedStr = document.getElementById('seed').value.trim();
      const seedVal = seedStr ? Array.from(seedStr).reduce((a,c)=>a+c.charCodeAt(0), 0) : (Math.random()*1e9)|0;
      const rng = mulberry32(seedVal);
      const profile = difficultyProfiles[state.difficulty] || difficultyProfiles.relaxed;
      const preparedCategories = profile.prepare(state.categories, rng).filter(cat => cat.items.length && cat.pick > 0);
      const picks = [];

      preparedCategories.forEach(cat => {
        const pool = seededShuffle(cat.items, rng);
        const count = Math.min(cat.pick, pool.length);
        if (!count) return;
        const plannedCount = count;
        let selection = pool.slice(0, count);
        if (cat.strategy === 'mayhem' && cat.forceAwkward && cat.forceAwkward.length) {
          selection = ensureAwkwardPresence(selection, pool, cat.forceAwkward);
        } else if (cat.strategy === 'standard' && profile.label === 'Balanced') {
          // no-op but keeps intent explicit
        }
        let bonusApplied = false;
        if (cat.strategy === 'mayhem' && cat.bonusRoll && pool.length > count) {
          selection.push(pool[count]);
          bonusApplied = true;
        }
        picks.push({ name: cat.name, items: selection, planned: plannedCount, bonusApplied, strategy: cat.strategy });
      });

      const lines = [];
      lines.push(`BL2 Random Playthrough (${profile.label})`);
      lines.push(`Seed: ${seedStr || seedVal}`);
      lines.push(`Source: ${state.configSource}`);
      const flavour = DIFFICULTY_FLAVOUR[state.difficulty] || '';
      if (flavour) {
        lines.push(flavour);
      }
      lines.push('');
      picks.forEach(p=>{
        lines.push(`[${p.name}]`);
        p.items.forEach(x=>lines.push(`- ${x}`));
        lines.push('');
      });
      const out = lines.join('\n');
      renderResultSummary(profile.label, seedStr || seedVal, state.configSource, flavour);
      renderResultGrid(picks);
      window.__lastRunText = out;
    }

    function downloadRun() {
      const txt = window.__lastRunText || 'No run generated yet.';
      const blob = new Blob([txt], {type:'text/plain'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'BL2-random-run.txt';
      a.click();
      URL.revokeObjectURL(a.href);
    }
    document.getElementById('randomise').addEventListener('click', randomise);
    document.getElementById('download-run').addEventListener('click', downloadRun);

    document.querySelectorAll('#difficulty-options .chip').forEach(chip => {
      chip.addEventListener('click', () => selectDifficulty(chip.dataset.difficulty));
    });

    updateDifficultyChips();
    updateDifficultyDescription();
    bootstrapConfig();
  </script>
</body>
</html>
